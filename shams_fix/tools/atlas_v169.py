from __future__ import annotations
"""Feasibility Boundary Atlas (v169)

Goal:
- Produce publishable atlas-style figure packs with *consistent captions* and a hashable manifest.
- SHAMS-native advantage: an atlas is a *geography* of feasibility, not just a point design.

This v169 implementation is **safe and additive**:
- Primary input: sensitivity_v164.json (fast, local atlas around witness)
- Optional future inputs: boundary traces from v157/v158 (not required here)

Outputs:
- atlas_pack_v169.zip (bytes) containing:
  - atlas_manifest_v169.json (SHA-256 per file)
  - atlas_summary_v169.md
  - figures/atlas_page_001.png
  - figures/atlas_page_001.json (caption + plotted data)

Safety:
- Visualization/packaging only. No physics/solver changes.
"""

from typing import Any, Dict, Optional, List, Tuple
import json, time, hashlib, io, zipfile, math

def _utc() -> str:
    return time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())

def _canon_json(o: Any) -> bytes:
    return json.dumps(o, indent=2, sort_keys=True, default=str).encode("utf-8")

def _sha_bytes(b: bytes) -> str:
    h=hashlib.sha256(); h.update(b); return h.hexdigest()

def _num(v):
    try:
        x=float(v)
        return x if math.isfinite(x) else None
    except Exception:
        return None

def _extract_local_grid_from_sensitivity(sens: Dict[str,Any]) -> Dict[str,Any]:
    """Create a tiny local 'atlas grid' from v164 sensitivity payload.

    We interpret per-variable +/- perturb evaluations if present; otherwise we fall back to ranking table.
    Output schema is stable for plotting and captions.
    """
    payload = sens.get("payload") if isinstance(sens, dict) else {}
    witness = payload.get("witness") or payload.get("baseline") or {}
    vars_ = payload.get("variables") or []
    rows = []
    for v in vars_:
        if not isinstance(v, dict):
            continue
        name = str(v.get("name") or "")
        if not name:
            continue
        d = {
            "name": name,
            "bounds": v.get("bounds"),
            "step": v.get("step"),
            "d_min_margin_dx": v.get("d_min_margin_dx"),
            "dominant_base": v.get("dominant_base"),
            "dominant_minus": v.get("dominant_minus"),
            "dominant_plus": v.get("dominant_plus"),
            "min_margin_base": v.get("min_margin_base"),
            "min_margin_minus": v.get("min_margin_minus"),
            "min_margin_plus": v.get("min_margin_plus"),
        }
        rows.append(d)
    return {"witness": witness, "rows": rows}

def _make_png_barplot(rows: List[Dict[str,Any]], title: str) -> bytes:
    """Render a simple bar plot PNG as bytes using matplotlib."""
    import matplotlib
    matplotlib.use("Agg")
    import matplotlib.pyplot as plt

    names=[]
    vals=[]
    for r in rows:
        nm=str(r.get("name") or "")
        dv=_num(r.get("d_min_margin_dx"))
        if nm and dv is not None:
            names.append(nm)
            vals.append(dv)
    # Keep stable ordering by absolute magnitude (descending)
    idx = sorted(range(len(vals)), key=lambda i: abs(vals[i]), reverse=True)[:12]
    names=[names[i] for i in idx]
    vals=[vals[i] for i in idx]

    fig=plt.figure(figsize=(10, 4.5), dpi=150)
    ax=fig.add_subplot(111)
    ax.bar(range(len(vals)), vals)
    ax.set_xticks(range(len(vals)))
    ax.set_xticklabels(names, rotation=45, ha="right")
    ax.set_ylabel("d(min_margin)/dx (finite difference)")
    ax.set_title(title)
    ax.grid(True, axis="y", alpha=0.3)
    fig.tight_layout()
    bio=io.BytesIO()
    fig.savefig(bio, format="png")
    plt.close(fig)
    return bio.getvalue()

def build_atlas_pack(
    *,
    sensitivity_v164: Dict[str,Any],
    policy: Optional[Dict[str,Any]] = None,
) -> Dict[str,Any]:
    if not (isinstance(sensitivity_v164, dict) and sensitivity_v164.get("kind") in ["shams_sensitivity_report","sensitivity_report","shams_sensitivity"]):
        # We accept SHAMS-native kind only, but don't hard fail on small naming drift.
        # Require payload structure at least.
        if not (isinstance(sensitivity_v164, dict) and isinstance(sensitivity_v164.get("payload"), dict)):
            raise ValueError("sensitivity_v164 must be a v164 sensitivity report dict (with payload).")

    policy = policy if isinstance(policy, dict) else {}
    issued=_utc()

    grid=_extract_local_grid_from_sensitivity(sensitivity_v164)
    rows=grid.get("rows") or []
    witness=grid.get("witness") or {}

    caption = (
        "Atlas Page 001 — Local feasibility leverage around the selected witness. "
        "Bars show finite-difference d(min_margin)/dx from v164 sensitivity; larger magnitude indicates stronger leverage. "
        "This page is generated by SHAMS v169 and is hash-tracked in the atlas manifest."
    )

    page_json={
        "page": 1,
        "title": "Local Feasibility Leverage (v164→v169)",
        "caption": caption,
        "issued_utc": issued,
        "witness": witness,
        "rows": rows[:200],
    }

    png=_make_png_barplot(rows, title="Local feasibility leverage (v169)")

    # Pack files
    files={
        "atlas_manifest_v169.json": b"",  # placeholder
        "atlas_summary_v169.md": b"",
        "figures/atlas_page_001.png": png,
        "figures/atlas_page_001.json": _canon_json(page_json),
    }

    summary = []
    summary.append("# Feasibility Boundary Atlas (v169)")
    summary.append("")
    summary.append(f"- Issued: {issued}")
    summary.append(f"- Generator: {policy.get('generator','ui')}")
    summary.append("")
    summary.append("## Contents")
    summary.append("- Page 001: Local feasibility leverage around witness (from v164 sensitivity).")
    summary.append("")
    summary.append("## Caption policy")
    summary.append("Captions are generated *once* per page and embedded in the corresponding page JSON to prevent mixed captions.")
    summary.append("")
    files["atlas_summary_v169.md"]="\n".join(summary).encode("utf-8")

    manifest={
        "kind":"shams_atlas_manifest",
        "version":"v169",
        "issued_utc": issued,
        "generator": policy.get("generator","ui"),
        "pages":[
            {"page":1, "png":"figures/atlas_page_001.png", "json":"figures/atlas_page_001.json"}
        ],
        "files":[],
    }
    for name,b in sorted(files.items()):
        if name=="atlas_manifest_v169.json":
            continue
        manifest["files"].append({"name": name, "sha256": _sha_bytes(b), "bytes": len(b)})
    man_bytes=_canon_json(manifest)
    files["atlas_manifest_v169.json"]=man_bytes

    # zip bytes
    bio=io.BytesIO()
    with zipfile.ZipFile(bio, "w", compression=zipfile.ZIP_DEFLATED) as z:
        for name,b in files.items():
            z.writestr(name, b)
    zip_bytes=bio.getvalue()

    out={
        "kind":"shams_atlas_pack",
        "version":"v169",
        "issued_utc": issued,
        "integrity":{"zip_sha256": _sha_bytes(zip_bytes)},
        "payload":{"manifest": manifest},
    }
    return {"pack": out, "zip_bytes": zip_bytes, "manifest": manifest}
